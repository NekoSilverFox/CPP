#include <iostream>
#include <iomanip>
#include <ctime>

using namespace std;

//函数声明（在文件末尾的定义）
// !!! 在函数内部，不检查参数的正确性，
// !!! 调用无效值时可能导致错误

// Функция возвращает сумму элементов массива
int getSum(int* /*array*/, int /*size*/);

// Функция возвращает среднее значение элементов двумерного массива постоянной размерности
double getAverage(int* /*array*/, int /*nRow*/, int /*nColumn*/);

// Функция меняет местами две строки матрицы без непосредственного перемещения элементов в памяти
// !!! защиты от выхода из допустимого диапазона номеров нет
//该函数交换矩阵的两行，而不直接移动内存中的元素
// !!! 无号码范围保护
void swapRows(int** /*array*/, int /*iLine1*/, int /*iLine2*/);

int main()
{
	srand(time(0));

	int ivar1 = 10;
	int* iptr1 = &ivar1;	// объявление и инициализация указателя значением адреса переменной var1
	int* iptr2(&ivar1);		// другой вариант (равнозначный) объявления и инициализации указателя
	int* iptr3 = iptr1;		// объявление и инициализация указателя значением другого указателя
	// Важно отметить, что переменная iptr1 имеет тип int* (указатель на int),
	// выражение *iptr1 возвращает значение типа int (значение по адресу из iptr1),
	// переменная ivar1 имеет тип int,
	// выражение &ivar1 возвращает значение типа int*,

	// Выведем все переменные и адреса
	cout << "&var1=" << &ivar1 << ", var1=" << ivar1 << endl
		<< "ptr1=" << iptr1 << ", *ptr1=" << *iptr1 << endl
		<< "ptr2=" << iptr2 << ", *ptr2=" << *iptr2 << endl
		<< "ptr3=" << iptr3 << ", *ptr3=" << *iptr3 << endl;
	cout << endl;

	*iptr3 = 20;	// изменение значения по адресу (как вы думете, что выведется теперь?)
	cout << "&var1=" << &ivar1 << ", var1=" << ivar1 << endl
		<< "ptr1=" << iptr1 << ", *ptr1=" << *iptr1 << endl
		<< "ptr2=" << iptr2 << ", *ptr2=" << *iptr2 << endl
		<< "ptr3=" << iptr3 << ", *ptr3=" << *iptr3 << endl;
	cout << endl;

	double dvar1 = 2.5;
	// Указателю на void (типу void*) можно присвоить значение уазателя на любой другой тип
	// К сожалению, производить с типом void* какие-либо операции (разыменование, изменение значения,...) нельзя (если хотите - попробуйте)
	// Это логично, ведь компилятор не может знать, как интерпретировать значение по данному адресу
	void* vptr = &dvar1;
	double* dptr1;
	// Использовать тип void* можно совместно с явным приведением типов
	// void *类型可以与显式类型转换结合使用
	dptr1 = (double*)vptr;
	cout << "vptr=" << vptr << ", *((double*)vptr)=" << *((double*)vptr) << endl
		<< "&dvar1=" << &dvar1 << ", dvar1=" << dvar1 << endl
		<< "dptr1=" << dptr1 << ", *dptr1=" << *dptr1 << endl;
	cout << endl;

	// Создание двумерного массива в статической области памяти и передача его в функцию при помощи указателя
	const int N_ARRAY = 5;
	int iArray[N_ARRAY][N_ARRAY];

	// Инициалиация элементов массива случайными значениями от 0 до 9 и их вывод 
	for (int i = 0; i < N_ARRAY; i++)
	{
		for (int j = 0; j < N_ARRAY; j++)
		{
			iArray[i][j] = rand() % 10;
			cout << setw(2) << iArray[i][j];
		}
		cout << endl;
	}

	// Вывод среднего значения элементов массива
	cout << "average value: " << getAverage(*iArray, N_ARRAY, N_ARRAY) << endl;
	// Обратите внимание на то, что в функцию передаётся *iArray, а не iArray
	// *iArray имеет тип int* (чего и требует наша функция),
	// тогда как iArray имеет тип int(*)[N_ARRAY], т.е. "указатель на массив int размером N_ARRAY"

	cout << endl;

	int nDynArray = 5;	// размер массива (переменная!)

	// Выделение памяти под массив из nDynArray элементов типа int
	// и помещение указателя на эту память в переменную aptr
	// Обратите внимание, что nDynArray - переменная, а не константа

	int* dynArray = new int[nDynArray];
	for (int i = 0; i < nDynArray; i++)
	{
		// К элементам массива можно обращаться *(dynArray + i), а можно dynArray[i], 
		// а можно dynArray[i],что одно и то же
		*(dynArray + i) = rand() % 10;
	}

	for (int i = 0; i < nDynArray; i++)
	{
		cout << setw(2) << dynArray[i];
	}
	cout << endl;

	cout << "Sum of the elements of the array is " << getSum(dynArray, nDynArray) << endl;

	// Оператор delete освобождает память, привязанную к указателю; 
	// Для массивов требуются скобки delete[]
	delete[] dynArray;

	cout << endl;

	// Создание динамического двумерного массива и передача его в функцию

	int nRow = 7;		// размеры массива; это переменные => их можно вводить с клавиатуры либо вычислять,
	int nColumn = 5;    // но сейчас для простоты зададим их     	


	// Объявление указателя на указатель на int - адрес двумерного массива
	int** dynTwoArray;

	// Выделение памяти на массив из size указателей на int; new вернёт int**
	dynTwoArray = new int* [nRow];

	// Выделение памяти для каждой строки массива
	for (int i = 0; i < nRow; i++)
	{
		*(dynTwoArray + i) = new int[nColumn];	// можно (и даже лучше) dynTwoArray[i] = new int[nColumn]; 
												// но сейчас для наглядности так;
												//а вообще выражения *(array+i) и array[i] эквивалентны
	}

	// Инициалиация и вывод элементов массива
	for (int i = 0; i < nRow; i++)
	{
		for (int j = 0; j < nColumn; j++)
		{
			*(*(dynTwoArray + i) + j) = rand() % 10; // соответственно *(*(array + i) + j) эквивалентно array[i][j]
			cout << setw(2) << dynTwoArray[i][j];    // теперь воспользуюсь способом со скобками
		}
		cout << endl;
	}

	cout << endl;

	// Поменяю местами вторую и шестую строки матрицы (помним, что индексы начинаются с 0)
	// 交换矩阵的第二行和第六行（请记住索引从0开始）
	swapRows(dynTwoArray, 1, 5);

	for (int i = 0; i < nRow; i++)
	{
		for (int j = 0; j < nColumn; j++)
		{
			cout << setw(2) << dynTwoArray[i][j];
		}
		cout << endl;
	}
	cout << endl;

	for (int i = 0; i < nRow; i++)	// освобождение памяти производится в порядке обратном выделению
	{
		delete[] * (dynTwoArray + i);
	}

	delete[] dynTwoArray;

	return 0;
}

// Функция возвращает сумму элементов массива
int getSum(int* array, int size)
{
	int res = 0;
	for (int i = 0; i < size; i++)
	{
		res += *(array + i);
	}
	return res;
}

// Функция считает и возвращает среднее значение элементов двумерного массива
// Обратите внимание, что размеры массива передаются функции как параметры, а не жёстко указываются в объявлении
// Стоит вспомнить, что двумерный массив представляет собой массив одномерных массивов, а его элементы располагаются в памяти последовательно
// Первый аргумент функции типа int* будем понимать как указатель на первый элемент первого одномерного массива
// Именно поэтому в функцию из main был передан *iarr, а не iarr, т.к. iarr представляет собой указатель на первый одномерный массив, а не на первый элемент
//函数计算并返回二维数组元素的平均值
//注意，数组的维数作为参数传递给函数，并且在声明中未进行硬编码
//值得一提的是，二维数组是一维数组的数组，其元素顺序位于内存中
// int *类型的函数的第一个参数将被理解为指向第一个一维数组的第一个元素的指针
//这就是为什么* iarr从main而不是iarr转移到函数的原因，因为iarr是第一个一维数组的指针，而不是第一个元素的指针

double getAverage(int* array, int nRow, int nColumn)
{
	double sum = 0;
	for (int i = 0; i < nRow; i++)
	{
		for (int j = 0; j < nColumn; j++)
		{
			// Вычисляем адрес элемента array[i][j] как адрес начала (array) плюс 
			// смещение на кол-во строк (nColom*i) плюс смещение внутри строки (j)
			sum += *(array + nColumn * i + j);
		}
	}
	return sum / (nRow * nColumn);
}

// Функция меняет местами две строки матрицы без непосредственного перемещения элементов в памяти
// !!! Защиты от выхода из допустимого диапазона номеров не сделано

void swapRows(int** array, int iLine1, int iLine2)
{
	int* temp;
	temp = *(array + iLine1);
	*(array + iLine1) = *(array + iLine2);
	array[iLine2] = temp;	// array[iLine2] то же, что и *(array + iLine2); 
							// хотя в реальности, конечно, стоит пользоваться какой-либо одной нотацией
}
// Эта функция прекрасно показывает, что указатели позволяют нам быстро логически перемещать довольно большие объёмы данных
// без их физического переноса в памяти